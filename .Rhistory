}
if (pass) accept_ratio = accept_ratio + 1
else pass <- T
}
accept_ratio / n
}
test <- function(n, d) {
accept_ratio <- 0
pass <- T
num <- 1
dem <- 1
for (i in seq_len(n)) {
for (j in seq_len(d)) {
num <- num * dnorm(runif(1, min = 2, max = 6), mean = 0, sd = 1)
dem <- dem * dnorm(4, mean = 0, sd = 1)
}
u <- runif(1)
if (u < (num / dem)) {
accept_ratio = accept_ratio + 1
}
}
accept_ratio / n
}
cat("Acceptance ratio for univariate:", test(n, 1), '\n')
num / dem
accept_ratio <- 0
pass <- T
num <- 1
dem <- 1
for (i in seq_len(n)) {
for (j in seq_len(d)) {
num <- num * dnorm(runif(1, min = 2, max = 6), mean = 0, sd = 1)
dem <- dem * dnorm(4, mean = 0, sd = 1)
}
u <- runif(1)
if (u < (num / dem)) {
accept_ratio = accept_ratio + 1
}
}
set.seed(1)
n <- 10^4
test1 <- function(n, d) {
accept_ratio <- 0
pass <- T
for (i in seq_len(n)) {
for (j in seq_len(d)) {
prop <- runif(1, min = 2, max = 6)
u <- runif(1)
if (u > (dnorm(prop, mean = 0, sd = 1) / dnorm(4, mean = 0, sd = 1))) {
pass <- F
}
}
if (pass) accept_ratio = accept_ratio + 1
else pass <- T
}
accept_ratio / n
}
test <- function(n, d) {
accept_ratio <- 0
pass <- T
num <- 1
dem <- 1
for (i in seq_len(n)) {
for (j in seq_len(d)) {
num <- num * dnorm(runif(1, min = 2, max = 6), mean = 0, sd = 1)
dem <- dem * dnorm(4, mean = 0, sd = 1)
}
u <- runif(1)
if (u < (num / dem)) {
accept_ratio = accept_ratio + 1
}
}
accept_ratio / n
}
cat("Acceptance ratio for univariate:", test(n, 1), '\n')
set.seed(1)
n <- 10^4
test1 <- function(n, d) {
accept_ratio <- 0
pass <- T
for (i in seq_len(n)) {
for (j in seq_len(d)) {
prop <- runif(1, min = 2, max = 6)
u <- runif(1)
if (u > (dnorm(prop, mean = 0, sd = 1) / dnorm(4, mean = 0, sd = 1))) {
pass <- F
}
}
if (pass) accept_ratio = accept_ratio + 1
else pass <- T
}
accept_ratio / n
}
test <- function(n, d) {
accept_ratio <- 0
pass <- T
num <- 1
dem <- 1
for (i in seq_len(n)) {
for (j in seq_len(d)) {
num <- num * dnorm(runif(1, min = 2, max = 6), mean = 0, sd = 1)
dem <- dem * dnorm(4, mean = 0, sd = 1)
}
print(num / dem)
u <- runif(1)
if (u < (num / dem)) {
accept_ratio = accept_ratio + 1
}
}
accept_ratio / n
}
cat("Acceptance ratio for univariate:", test(n, 1), '\n')
set.seed(1)
n <- 10^4
test1 <- function(n, d) {
accept_ratio <- 0
pass <- T
for (i in seq_len(n)) {
for (j in seq_len(d)) {
prop <- runif(1, min = 2, max = 6)
u <- runif(1)
if (u > (dnorm(prop, mean = 0, sd = 1) / dnorm(4, mean = 0, sd = 1))) {
pass <- F
}
}
if (pass) accept_ratio = accept_ratio + 1
else pass <- T
}
accept_ratio / n
}
test <- function(n, d) {
accept_ratio <- 0
pass <- T
num <- 1
dem <- 1
for (i in seq_len(n)) {
for (j in seq_len(d)) {
num <- num * dnorm(runif(1, min = 2, max = 6), mean = 0, sd = 1)
dem <- dem * dnorm(4, mean = 0, sd = 1)
}
print(num / dem)
u <- runif(1)
if (u < (num / dem)) {
accept_ratio = accept_ratio + 1
}
}
accept_ratio / n
}
cat("Acceptance ratio for univariate:", test(n, 1), '\n')
for (j in seq_len(d)) {
print(num)
num <- num * dnorm(runif(1, min = 2, max = 6), mean = 0, sd = 1)
print(num)
dem <- dem * dnorm(4, mean = 0, sd = 1)
}
set.seed(1)
n <- 10^4
test1 <- function(n, d) {
accept_ratio <- 0
pass <- T
for (i in seq_len(n)) {
for (j in seq_len(d)) {
prop <- runif(1, min = 2, max = 6)
u <- runif(1)
if (u > (dnorm(prop, mean = 0, sd = 1) / dnorm(4, mean = 0, sd = 1))) {
pass <- F
}
}
if (pass) accept_ratio = accept_ratio + 1
else pass <- T
}
accept_ratio / n
}
test <- function(n, d) {
accept_ratio <- 0
pass <- T
num <- 1
dem <- 1
for (i in seq_len(n)) {
for (j in seq_len(d)) {
print(num)
num <- num * dnorm(runif(1, min = 2, max = 6), mean = 0, sd = 1)
print(num)
dem <- dem * dnorm(4, mean = 0, sd = 1)
}
print(num / dem)
u <- runif(1)
if (u < (num / dem)) {
accept_ratio = accept_ratio + 1
}
}
accept_ratio / n
}
cat("Acceptance ratio for univariate:", test(n, 1), '\n')
set.seed(1)
n <- 10^4
test1 <- function(n, d) {
accept_ratio <- 0
pass <- T
for (i in seq_len(n)) {
for (j in seq_len(d)) {
prop <- runif(1, min = 2, max = 6)
u <- runif(1)
if (u > (dnorm(prop, mean = 0, sd = 1) / dnorm(4, mean = 0, sd = 1))) {
pass <- F
}
}
if (pass) accept_ratio = accept_ratio + 1
else pass <- T
}
accept_ratio / n
}
test <- function(n, d) {
accept_ratio <- 0
pass <- T
num <- 1
dem <- 1
for (i in seq_len(n)) {
for (j in seq_len(d)) {
num <- num * dnorm(runif(1, min = 2, max = 6), mean = 0, sd = 1)
dem <- dem * dnorm(4, mean = 0, sd = 1)
}
print(num)
u <- runif(1)
if (u < (num / dem)) {
accept_ratio = accept_ratio + 1
}
}
accept_ratio / n
}
cat("Acceptance ratio for univariate:", test(n, 1), '\n')
set.seed(1)
n <- 10^4
test1 <- function(n, d) {
accept_ratio <- 0
pass <- T
for (i in seq_len(n)) {
for (j in seq_len(d)) {
prop <- runif(1, min = 2, max = 6)
u <- runif(1)
if (u > (dnorm(prop, mean = 0, sd = 1) / dnorm(4, mean = 0, sd = 1))) {
pass <- F
}
}
if (pass) accept_ratio = accept_ratio + 1
else pass <- T
}
accept_ratio / n
}
test <- function(n, d) {
accept_ratio <- 0
pass <- T
for (i in seq_len(n)) {
num <- 1
dem <- 1
for (j in seq_len(d)) {
num <- num * dnorm(runif(1, min = 2, max = 6), mean = 0, sd = 1)
dem <- dem * dnorm(4, mean = 0, sd = 1)
}
print(num)
u <- runif(1)
if (u < (num / dem)) {
accept_ratio = accept_ratio + 1
}
}
accept_ratio / n
}
cat("Acceptance ratio for univariate:", test(n, 1), '\n')
set.seed(1)
n <- 10^4
test1 <- function(n, d) {
accept_ratio <- 0
pass <- T
for (i in seq_len(n)) {
for (j in seq_len(d)) {
prop <- runif(1, min = 2, max = 6)
u <- runif(1)
if (u > (dnorm(prop, mean = 0, sd = 1) / dnorm(4, mean = 0, sd = 1))) {
pass <- F
}
}
if (pass) accept_ratio = accept_ratio + 1
else pass <- T
}
accept_ratio / n
}
test <- function(n, d) {
accept_ratio <- 0
pass <- T
for (i in seq_len(n)) {
num <- 1
dem <- 1
for (j in seq_len(d)) {
num <- num * dnorm(runif(1, min = 2, max = 6), mean = 0, sd = 1)
dem <- dem * dnorm(4, mean = 0, sd = 1)
}
u <- runif(1)
if (u < (num / dem)) {
accept_ratio = accept_ratio + 1
}
}
accept_ratio / n
}
cat("Acceptance ratio for univariate:", test(n, 1), '\n')
cat('Acceptance ratio for trivariate:', test(n, 3), '\n')
cat('Acceptance ratio for 10D:', test(n, 10))
knitr::opts_chunk$set(echo = TRUE)
# write your code here
X <- rbind(c(10, 10))
X <- matrix(c(X, rep(NA, 2*999)), ncol = 2, byrow = T)
covar <- matrix(c(1, 0.7, 0.7, 1), nrow = 2)
for (i in seq_len(999)) {
mean_x1 <- covar[1,2] * (1 / covar[2,2]) * X[i, 2]
covar_x1 <- covar[1,1] - covar[1,2] * covar[2,1] / covar[2,2]
prop_x1 <- rnorm(1, mean = mean_x1, sd = sqrt(covar_x1))
mean_x2 <- covar[1,2] * (1 / covar[1,1]) * X[i, 2]
covar_x2 <- covar[2,2] - covar[1,2] * covar[2,1] / covar[1,1]
prop_x2 <- rnorm(1, mean = mean_x2, sd = sqrt(covar_x2))
prop <- c(prop_x1, prop_x2)
pmove <- f(prop) / f(X[i,])
u <- runif(1)
if (u < pmove) X[i + 1,] <- prop
else X[i + 1,] <- X[i,]
}
plot(X[ , 1], X[ , 2], type = 'b', pch = 19, cex = 0.2, xlab = "X1", ylab = "X2")
plot(X[50:1000, 1], X[50:1000, 2], pch = 19, cex = 0.2, xlab = "X1", ylab = "X2")
load("tm.Rdata")
library(ggplot2)
library(reshape2)
## a graphic representation of the transition matrix
ggplot(melt(trans_prob_mat), aes(Var2, Var1)) + geom_tile(aes(fill = value)) +
scale_fill_gradient(low = "white", high = "black", limits = c(0, max(trans_prob_mat))) +
labs(x = "Second Letter", y = "First Letter", fill = "Prob") +
scale_y_discrete(limits = rev(levels(melt(trans_prob_mat)$Var1))) +
coord_equal()
decode <- function(mapping, coded) {
coded <- toupper(coded)
decoded <- coded
for (i in 1:nchar(coded)) {
if (substring(coded, i, i) %in% LETTERS) {
substring(decoded, i, i) <- LETTERS[mapping == substring(coded, i, i)]
}
}
decoded
}
# log probability based on the two-letter combinations in the text string
two_letter_logp <- function(text) {
logprob <- 0
last_letter <- ""
for (i in 1:nchar(text)) {
cur_letter <- substring(text, i, i)
row <- which(rownames(trans_mat) == last_letter)
col <- which(colnames(trans_mat) == cur_letter)
if (cur_letter %in% toupper(letters)) {
logprob <- logprob + log(trans_prob_mat[row, col])
last_letter <- cur_letter
} else if (last_letter != "") {
logprob <- logprob + log(trans_prob_mat[row, 27])
last_letter <- ""
}
}
row <- which(rownames(trans_mat) == last_letter)
if (last_letter != "") {
logprob <- logprob + log(trans_prob_mat[row, 27])
last_letter <- ""
}
logprob
}
# This code is based on code found in Machine Learning for Hackers Chapter 7
# Author: Drew Conway (drew.conway@nyu.edu) and John Myles White (jmw@johnmyleswhite.com)
# I have modified it to incorporate the two-letter combos
# load the database into R
load(file.path("lex.Rdata"))
# This function looks up a single word (one-gram) in the database and
# returns the probability. If the word is not found in the database,
# it returns a very small non-zero value.
# (A value of 0 would become -Infinity, which would be problematic)
one_gram_prob <- function(word, lex) {
row <- which(lex$word == word)
if (length(row) == 0) {
# for words that don't exist in the lexicon,
# return a small non-zero probability
return( 1e-10 ) # tuneable parameter
} else {
# return the word probability if it can find it
return(lex[[row, 2]])
}
}
# Calculates the log-probability of the text. It takes the text, splits it
# at the spaces and finds the total log probability of all the words in the text
log_prob_words <- function(text, lex) {
logprob <- 0
text <- tolower(text)
text <- gsub('[[:punct:] ]+',' ', text)
text <- unlist(strsplit(text, " "))
for (string in text) {
logprob <- logprob + log(one_gram_prob(string, lex))
}
logprob
}
# script starts here
decipher <- function(coded_txt, weight, seed) {
set.seed(seed)
mapping <- sample(toupper(letters)) # initialize a random mapping
cur_decoded_text <- decode(mapping, coded_txt)
cur_2letter_prob <- two_letter_logp(cur_decoded_text)
cur_word_prob <- log_prob_words(cur_decoded_text, lexical.database)
#weight <- 0.07 # tuneable parameter
cur_combined_loglike <- cur_2letter_prob + weight * cur_word_prob
best_decode <- cur_decoded_text
max_combined_loglike <- cur_combined_loglike
i <- 1
iters <- 1500
# the metropolis algorithm
while (i <= iters) {
# propose a new mapping by swapping two letters
proposal <- sample(1:26, 2) # select 2 letters to switch
proposed_mapping <- mapping
proposed_mapping[proposal[1]] <- mapping[proposal[2]]
proposed_mapping[proposal[2]] <- mapping[proposal[1]]
# calculate the probability of the proposed mapping
proposed_decoded_text <- decode(proposed_mapping, coded_txt)
proposed_2letter_prob <- two_letter_logp(proposed_decoded_text)
proposed_word_prob <- log_prob_words(proposed_decoded_text, lexical.database)
prop_combined_loglike <- proposed_2letter_prob + weight * proposed_word_prob
# if u < p(propose)/p(current) accept
# equivalent to: if log(u) < (logp(proposed) - logp(current))
if (log(runif(1)) < (prop_combined_loglike - cur_combined_loglike)) {
mapping <- proposed_mapping
cur_decoded_text <- proposed_decoded_text
cur_combined_loglike <- prop_combined_loglike
# update the best decoding if it is the best
if (cur_combined_loglike > max_combined_loglike) {
set.seed(1)
n <- 10^4
test <- function(n, d) {
accept_ratio <- 0
pass <- T
for (i in seq_len(n)) {
num <- 1
dem <- 1
for (j in seq_len(d)) {
num <- num * dnorm(runif(1, min = 2, max = 6), mean = 0, sd = 1)
dem <- dem * dnorm(4, mean = 0, sd = 1)
}
u <- runif(1)
if (u < (num / dem)) {
accept_ratio = accept_ratio + 1
}
}
accept_ratio / n
}
cat("Acceptance ratio for univariate:", test(n, 1), '\n')
cat('Acceptance ratio for trivariate:', test(n, 3), '\n')
cat('Acceptance ratio for 10D:', test(n, 10))
# write your code here
X <- rbind(c(10, 10))
f <- function(x){
covar <- matrix(c(1, 0.7, 0.7, 1), nrow = 2)
num <- exp(-0.5 * t(x) %*% solve(covar) %*% x)
num / sqrt((2 * pi)^2 * det(covar))
}
X <- matrix(c(X, rep(NA, 2*999)), ncol = 2, byrow = T)
for (i in seq_len(999)) {
prop <- c(runif(1, min = X[i, 1] - 1, max = X[i, 1] + 1),
runif(1, min = X[i, 2] - 1, max = X[i, 2] + 1))
pmove <- f(prop) / f(X[i,])
u <- runif(1)
if (u < pmove) X[i + 1,] <- prop
else X[i + 1,] <- X[i,]
}
# the plot command assuming the results are stored in a 1000 x 2 matrix called X
plot(X[ , 1], X[ , 2], type = 'b', pch = 19, cex = 0.2, xlab = "X1", ylab = "X2")
# create another plot after removing the 'burn in values'
# adjust as necessary, this assumes the first 100 values are burn-in
plot(X[50:1000, 1], X[50:1000, 2], pch = 19, cex = 0.2, xlab = "X1", ylab = "X2")
# write your code here
X <- rbind(c(10, 10))
X <- matrix(c(X, rep(NA, 2*999)), ncol = 2, byrow = T)
covar <- matrix(c(1, 0.7, 0.7, 1), nrow = 2)
for (i in seq_len(999)) {
mean_x1 <- covar[1,2] * (1 / covar[2,2]) * X[i, 2]
covar_x1 <- covar[1,1] - covar[1,2] * covar[2,1] / covar[2,2]
prop_x1 <- rnorm(1, mean = mean_x1, sd = sqrt(covar_x1))
mean_x2 <- covar[1,2] * (1 / covar[1,1]) * X[i, 2]
covar_x2 <- covar[2,2] - covar[1,2] * covar[2,1] / covar[1,1]
prop_x2 <- rnorm(1, mean = mean_x2, sd = sqrt(covar_x2))
prop <- c(prop_x1, prop_x2)
pmove <- f(prop) / f(X[i,])
u <- runif(1)
if (u < pmove) X[i + 1,] <- prop
else X[i + 1,] <- X[i,]
}
plot(X[ , 1], X[ , 2], type = 'b', pch = 19, cex = 0.2, xlab = "X1", ylab = "X2")
plot(X[50:1000, 1], X[50:1000, 2], pch = 19, cex = 0.2, xlab = "X1", ylab = "X2")
plot(X[10:1000, 1], X[10:1000, 2], pch = 19, cex = 0.2, xlab = "X1", ylab = "X2")
## References
setwd("~/Stats140SL Zes/Stats140SL-COVID")
plot(lm(log(newcon[which(newcon > 0)]) ~ mask[which(newcon > 0)]))
newcon <- data$New_Confirmed / rep(statepop, nrow(data) / 50)
library(readr)
data <- read_csv("cleaned_data.csv")
library(dplyr)
newcon <- data$New_Confirmed / rep(statepop, nrow(data) / 50)
statepop <- c(4903185, 731545, 7278717, 3017804, 39512223, 5758736, 3565287, 973764, 21477737, 10617423, 1415872, 1787065, 12671821, 6732219, 3155070, 2913314, 4467673,
4648794, 1344212, 6045680, 6892503, 9986857, 5639632, 2976149, 6137428, 1068778, 1934408, 3080156, 1359711, 8882190, 2096829, 19453561,
10488084, 762062, 11689100, 3956971, 4217737, 12801989, 1059361, 5148714, 884659, 6829174, 28995881, 3205958, 623989, 8535519, 7614893, 1792147,
5822434, 578759)
newcon <- data$New_Confirmed / rep(statepop, nrow(data) / 50)
mask <- data$mask
summary(lm(log(newcon[which(newcon > 0)]) ~ mask[which(newcon > 0)]))
plot(lm(log(newcon[which(newcon > 0)]) ~ mask[which(newcon > 0)]))
